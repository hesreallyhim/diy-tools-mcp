# Ticket 1.5: Handle Edge Cases with Single Main Function Requirement

## Overview
Implement strict validation and clear handling for edge cases, enforcing a single `main` function entry point for all file-based functions.

**Note**: The requirement for `main` is temporary. A future enhancement will allow configurable entry points (see FUTURE-configurable-entry-points.md).

## Requirements
1. Enforce single `main` function per file
2. Handle syntax errors at registration time
3. Allow helper functions but only execute `main`
4. Provide clear error messages for all edge cases
5. Set output and file size limits

## Implementation Details

### Update src/tools/validator.ts

```typescript
export class FunctionValidator {
  private static readonly MAX_OUTPUT_SIZE = 1024 * 1024; // 1MB
  private static readonly MAX_RETURN_SIZE = 10 * 1024 * 1024; // 10MB

  async validate(spec: FunctionSpecification): Promise<void> {
    // Validate mutual exclusivity
    if (spec.code && spec.codePath) {
      throw new ValidationError('Cannot specify both code and codePath');
    }
    
    if (!spec.code && !spec.codePath) {
      throw new ValidationError('Must specify either code or codePath');
    }

    // For file-based functions
    if (spec.codePath) {
      const code = await this.loadAndValidateFile(spec.codePath, spec.language);
      await this.validateSingleMainFunction(code, spec.language);
    }
    
    // For inline functions
    if (spec.code) {
      await this.validateSingleMainFunction(spec.code, spec.language);
    }

    // Validate parameters schema
    this.validateParameterSchema(spec.parameters);
  }

  private async validateSingleMainFunction(code: string, language: SupportedLanguage): Promise<void> {
    const validator = getLanguageValidator(language);
    
    // Check syntax first
    const syntaxResult = await validator.checkSyntax(code);
    if (!syntaxResult.valid) {
      throw new ValidationError(
        `Syntax error in ${language} code at line ${syntaxResult.line}: ${syntaxResult.error}`
      );
    }
    
    // Check for main function
    const mainFunctions = validator.findMainFunctions(code);
    
    if (mainFunctions.length === 0) {
      throw new ValidationError(
        `No 'main' function found. File must define exactly one function named 'main'`
      );
    }
    
    if (mainFunctions.length > 1) {
      throw new ValidationError(
        `Multiple 'main' functions found at lines ${mainFunctions.join(', ')}. ` +
        `File must define exactly one function named 'main'`
      );
    }
    
    // Validate main function signature
    const signatureValid = validator.validateMainSignature(code, mainFunctions[0]);
    if (!signatureValid.valid) {
      throw new ValidationError(
        `Invalid 'main' function signature: ${signatureValid.error}`
      );
    }
  }
}
```

### Create src/utils/language-validators.ts

```typescript
interface LanguageValidator {
  checkSyntax(code: string): Promise<SyntaxResult>;
  findMainFunctions(code: string): number[]; // Returns line numbers
  validateMainSignature(code: string, lineNumber: number): SignatureResult;
}

class PythonValidator implements LanguageValidator {
  async checkSyntax(code: string): Promise<SyntaxResult> {
    // Use Python AST to check syntax
    const result = await this.runPythonCheck(code);
    return result;
  }
  
  findMainFunctions(code: string): number[] {
    const lines = code.split('\n');
    const mainFunctions: number[] = [];
    
    lines.forEach((line, index) => {
      // Match various Python function definition patterns
      if (/^def\s+main\s*\(/.test(line.trim())) {
        mainFunctions.push(index + 1);
      }
      // Also check for async def
      if (/^async\s+def\s+main\s*\(/.test(line.trim())) {
        mainFunctions.push(index + 1);
      }
    });
    
    return mainFunctions;
  }
  
  validateMainSignature(code: string, lineNumber: number): SignatureResult {
    const lines = code.split('\n');
    const mainLine = lines[lineNumber - 1];
    
    // Check if it accepts **kwargs or individual parameters
    if (!/def\s+main\s*\([^)]*\)/.test(mainLine)) {
      return {
        valid: false,
        error: "Main function must have valid parameter list"
      };
    }
    
    return { valid: true };
  }
  
  private async runPythonCheck(code: string): Promise<SyntaxResult> {
    const checkCode = `
import ast
import sys
import json

try:
    ast.parse('''${code.replace(/'/g, "\\'")}''')
    print(json.dumps({"valid": true}))
except SyntaxError as e:
    print(json.dumps({
        "valid": false,
        "line": e.lineno,
        "error": str(e.msg)
    }))
`;
    // Execute and parse result
    // ...
  }
}

class JavaScriptValidator implements LanguageValidator {
  async checkSyntax(code: string): Promise<SyntaxResult> {
    try {
      // Use a parser like acorn or babel
      const acorn = require('acorn');
      acorn.parse(code, { ecmaVersion: 2020 });
      return { valid: true };
    } catch (error) {
      return {
        valid: false,
        line: error.loc?.line || 1,
        error: error.message
      };
    }
  }
  
  findMainFunctions(code: string): number[] {
    const lines = code.split('\n');
    const mainFunctions: number[] = [];
    
    lines.forEach((line, index) => {
      // Match various JS function patterns
      if (/function\s+main\s*\(/.test(line)) {
        mainFunctions.push(index + 1);
      }
      if (/const\s+main\s*=\s*(async\s+)?(\([^)]*\)|[a-zA-Z_$][a-zA-Z0-9_$]*)\s*=>/.test(line)) {
        mainFunctions.push(index + 1);
      }
      if (/async\s+function\s+main\s*\(/.test(line)) {
        mainFunctions.push(index + 1);
      }
    });
    
    return mainFunctions;
  }
  
  validateMainSignature(code: string, lineNumber: number): SignatureResult {
    // JavaScript functions should accept a single object parameter
    const lines = code.split('\n');
    const mainLine = lines[lineNumber - 1];
    
    // Very basic check - could be enhanced
    if (!mainLine.includes('(')) {
      return {
        valid: false,
        error: "Main function must have parameter list"
      };
    }
    
    return { valid: true };
  }
}

// Similar validators for Bash, Ruby, TypeScript...
```

### Edge Case Examples

```typescript
// Test cases to handle:

// 1. No main function
const noMain = `
def helper(x):
    return x * 2
    
def process(y):
    return helper(y)
`;
// Error: "No 'main' function found"

// 2. Multiple main functions
const multipleMain = `
def main(x):
    return x

def main(y):  # Duplicate!
    return y * 2
`;
// Error: "Multiple 'main' functions found at lines 1, 4"

// 3. Syntax error
const syntaxError = `
def main(x)  # Missing colon
    return x
`;
// Error: "Syntax error at line 1: invalid syntax"

// 4. Helper functions are OK
const withHelpers = `
def helper(x):
    return x * 2

def main(value):
    return {
        "result": helper(value),
        "timestamp": datetime.now().isoformat()
    }
`;
// Valid! Only main() is executed

// 5. Runtime errors are not caught at registration
const runtimeError = `
def main(x):
    return x / 0  # Division by zero
`;
// Valid at registration, fails at execution
```

## Output Limiting

```typescript
// In executor.ts
class FunctionExecutor {
  private limitOutput(output: string): string {
    const MAX_OUTPUT = 1024 * 1024; // 1MB
    
    if (output.length > MAX_OUTPUT) {
      return output.substring(0, MAX_OUTPUT) + 
        '\n[OUTPUT TRUNCATED - exceeded 1MB limit]';
    }
    return output;
  }
}
```

## Testing
- Test files with no main function
- Test files with multiple main functions  
- Test files with syntax errors (various types)
- Test files with helper functions
- Test output size limiting
- Test all supported languages

## Acceptance Criteria
- [ ] Single main function enforced for all languages
- [ ] Syntax errors caught at registration with clear messages
- [ ] Helper functions allowed but not executed
- [ ] Output size limits implemented
- [ ] Clear error messages with line numbers
- [ ] All edge cases have tests